{"version":3,"sources":["js/cursor.js"],"names":["clientX","clientY","innerCursor","document","querySelector","initCursor","addEventListener","e","requestAnimationFrame","render","style","transform","group","stuckX","stuckY","fillOuterCursor","lastX","lastY","isStuck","showCursor","initCanvas","canvas","shapeBounds","paper","setup","strokeColor","isNoisy","polygon","Path","RegularPolygon","Point","strokeWidth","smooth","Group","applyMatrix","noiseObjects","segments","map","SimplexNoise","bigCoordinates","lerp","a","b","n","value","in_min","in_max","out_min","out_max","view","onFrame","event","position","bounds","width","scale","forEach","segment","i","point","set","length","x","y","noiseX","noise2D","count","noiseY","distortionX","distortionY","newX","newY","initHovers","handleMouseEnter","navItem","navItemBox","currentTarget","getBoundingClientRect","Math","round","left","top","height","handleMouseLeave","querySelectorAll","item"],"mappings":"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","file":"cursor.fb8818e1.js","sourceRoot":"..","sourcesContent":["// set the starting position of the cursor outside of the screen\r\nlet clientX = -100;\r\nlet clientY = -100;\r\nconst innerCursor = document.querySelector(\".cursor--small\");\r\n\r\nconst initCursor = () => {\r\n  // add listener to track the current mouse position\r\n  document.addEventListener(\"mousemove\", e => {\r\n    clientX = e.clientX;\r\n    clientY = e.clientY;\r\n  });\r\n  \r\n  // transform the innerCursor to the current mouse position\r\n  // use requestAnimationFrame() for smooth performance\r\n  const render = () => {\r\n    innerCursor.style.transform = `translate(${clientX}px, ${clientY}px)`;\r\n    \r\n    requestAnimationFrame(render);\r\n  };\r\n  requestAnimationFrame(render);\r\n};\r\n\r\ninitCursor();\r\n\r\nlet lastX = 0;\r\nlet lastY = 0;\r\nlet isStuck = false;\r\nlet showCursor = false;\r\nlet group, stuckX, stuckY, fillOuterCursor;\r\n\r\nconst initCanvas = () => {\r\n  const canvas = document.querySelector(\".cursor--canvas\");\r\n  const shapeBounds = {\r\n    width: 75,\r\n    height: 75\r\n  };\r\n  paper.setup(canvas);\r\n  const strokeColor = \"#eebbc3\";\r\n  const strokeWidth = 1;\r\n  const segments = 8;\r\n  const radius = 15;\r\n  \r\n  // we'll need these later for the noisy circle\r\n  const noiseScale = 150; // speed\r\n  const noiseRange = 4; // range of distortion\r\n  let isNoisy = false; // state\r\n  \r\n  // the base shape for the noisy circle\r\n  const polygon = new paper.Path.RegularPolygon(\r\n    new paper.Point(0, 0),\r\n    segments,\r\n    radius\r\n  );\r\n  polygon.strokeColor = strokeColor;\r\n  polygon.strokeWidth = strokeWidth;\r\n  polygon.smooth();\r\n  group = new paper.Group([polygon]);\r\n  group.applyMatrix = false;\r\n  \r\n  const noiseObjects = polygon.segments.map(() => new SimplexNoise());\r\n  let bigCoordinates = [];\r\n  \r\n  // function for linear interpolation of values\r\n  const lerp = (a, b, n) => {\r\n    return (1 - n) * a + n * b;\r\n  };\r\n  \r\n  // function to map a value from one range to another range\r\n  const map = (value, in_min, in_max, out_min, out_max) => {\r\n    return (\r\n      ((value - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min\r\n    );\r\n  };\r\n  \r\n  // the draw loop of Paper.js\r\n// (60fps with requestAnimationFrame under the hood)\r\npaper.view.onFrame = event => {\r\n    // using linear interpolation, the circle will move 0.2 (20%)\r\n    // of the distance between its current position and the mouse\r\n    // coordinates per Frame\r\n    if (!isStuck) {\r\n      // move circle around normally\r\n      lastX = lerp(lastX, clientX, 0.2);\r\n      lastY = lerp(lastY, clientY, 0.2);\r\n      group.position = new paper.Point(lastX, lastY);\r\n    } else if (isStuck) {\r\n      // fixed position on a nav item\r\n      lastX = lerp(lastX, stuckX, 0.2);\r\n      lastY = lerp(lastY, stuckY, 0.2);\r\n      group.position = new paper.Point(lastX, lastY);\r\n    }\r\n    \r\n    if (isStuck && polygon.bounds.width < shapeBounds.width) { \r\n      // scale up the shape \r\n      polygon.scale(1.08);\r\n    } else if (!isStuck && polygon.bounds.width > 30) {\r\n      // remove noise\r\n      if (isNoisy) {\r\n        polygon.segments.forEach((segment, i) => {\r\n          segment.point.set(bigCoordinates[i][0], bigCoordinates[i][1]);\r\n        });\r\n        isNoisy = false;\r\n        bigCoordinates = [];\r\n      }\r\n      // scale down the shape\r\n      const scaleDown = 0.92;\r\n      polygon.scale(scaleDown);\r\n    }\r\n    \r\n    // while stuck and big, apply simplex noise\r\n    if (isStuck && polygon.bounds.width >= shapeBounds.width) {\r\n      isNoisy = true;\r\n      // first get coordinates of large circle\r\n      if (bigCoordinates.length === 0) {\r\n        polygon.segments.forEach((segment, i) => {\r\n          bigCoordinates[i] = [segment.point.x, segment.point.y];\r\n        });\r\n      }\r\n      \r\n      // loop over all points of the polygon\r\n      polygon.segments.forEach((segment, i) => {\r\n        \r\n        // get new noise value\r\n        // we divide event.count by noiseScale to get a very smooth value\r\n        const noiseX = noiseObjects[i].noise2D(event.count / noiseScale, 0);\r\n        const noiseY = noiseObjects[i].noise2D(event.count / noiseScale, 1);\r\n        \r\n        // map the noise value to our defined range\r\n        const distortionX = map(noiseX, -1, 1, -noiseRange, noiseRange);\r\n        const distortionY = map(noiseY, -1, 1, -noiseRange, noiseRange);\r\n        \r\n        // apply distortion to coordinates\r\n        const newX = bigCoordinates[i][0] + distortionX;\r\n        const newY = bigCoordinates[i][1] + distortionY;\r\n        \r\n        // set new (noisy) coodrindate of point\r\n        segment.point.set(newX, newY);\r\n      });\r\n      \r\n    }\r\n    polygon.smooth();\r\n  };\r\n}\r\n\r\ninitCanvas();\r\n\r\nconst initHovers = () => {\r\n\r\n    // find the center of the link element and set stuckX and stuckY\r\n    // these are needed to set the position of the noisy circle\r\n    const handleMouseEnter = e => {\r\n      const navItem = e.currentTarget;\r\n      const navItemBox = navItem.getBoundingClientRect();\r\n      stuckX = Math.round(navItemBox.left + navItemBox.width / 2);\r\n      stuckY = Math.round(navItemBox.top + navItemBox.height / 2);\r\n      isStuck = true;\r\n    };\r\n    \r\n    // reset isStuck on mouseLeave\r\n    const handleMouseLeave = () => {\r\n      isStuck = false;\r\n    };\r\n    \r\n    // add event listeners to all items\r\n    const linkItems = document.querySelectorAll(\".link\");\r\n    linkItems.forEach(item => {\r\n      item.addEventListener(\"mouseenter\", handleMouseEnter);\r\n      item.addEventListener(\"mouseleave\", handleMouseLeave);\r\n    });\r\n  };\r\n  \r\n  initHovers();\r\n"]}